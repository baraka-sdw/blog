---
title: "JVM学习笔记之HotSpot虚拟机对象探秘"
date: 2018-11-04T22:14:09+08:00
draft: true
featured_image: https://sdw-1254060699.cos.ap-chengdu.myqcloud.com/bing_photos/20181104.jpg
---
<p class="description">Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建。在语言层面上,创建对象（例如克隆，反序列话），通常仅仅一个new关键字而已，而在虚拟机中，对象（限于普通Java对象，不包括数组和Class对象等）的建立优势怎样的一个过程呢？ </p>
<!-- more -->
### <div class="note default"><p>1.对象的创建</p></div>
虚拟机遇到一条New指令时，首先检查这个指令的参数是否能在常量池中定位到一个符号的引用，并且检查这个符号引用代表的类是否被加载,解析和初始化过。如果没有那必须先执行相应的类加载过程。
</br>

在类加载的检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在一边，中间放着一个指针作为分界点的指示器,那所分配的内存就仅仅是把那个指针向空闲那边挪动一段与对象相等的距离，这种分配方式成为<font color=red>“指针碰撞”（Bump the Pointer）</font>。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到足够大的空间划分给对象实例,并更新列表上的记录，这种分配方式称为<font color=red>"空闲列表"（Free List）</font>。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用CMS这种基于<font color=red>Serial,ParNew等带Compact</font>过程的收集器时，系统采用的分配算法是指针碰撞，而使用<font color=red>CMS</font>这种基于<font color=red>Mark-Sweep</font>算法的收集器时，通常采用空闲列表。
</br>
接下来，解决并发情况下，对象频繁创建而带来的线程安全问题,解决这个问题目前有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存的动作按照线程划分为不同的空间中进行，即每一个线程在Java堆中预先分配一小块内存，称为本地线程缓冲(Thread Local Allocation Buffer,TLAB).哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否TLAB,可以通过-XX:+/-UseTLAB参数来设定。


### <div class="note default"><p>2.对象的内存布局</p></div>
